---
title: 接雨水
tags: 算法
aside:
  toc: true
---

<!--more-->

##  题目描述
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

### 示例

<div  align="center">
<img src= "
https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png
"/>
</div>


```html
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```

## 解法

考虑任意位置$i$，它的雨水量取决于$i$两边的最大高度的最小值，即左边的最大高度 $LMax(i)$ 和右边的最大高度 $RMax(i)$ 中的较小值，设当前位置的高度为 $h(i)$，那么当前位置的雨水量为$f(i)$，有：

$$ f(i) = min(LMax(i), RMax(i)) - h(i)$$

那么，总的接水量就是所有位置的雨水量之和。

$$\sum_{i=1}^{n} f(i) = \sum_{i=1}^{n} min(LMax(i), RMax(i)) - h(i)$$

我们想要知道每个位置的左边最大值和右边最大值，一个比较容易想到的方法就是分别从左到右和从右到左遍历一次，分别记录每个位置的左边最大值和右边最大值。

$$LMax(i) = max(LMax(i-1), h(i-1))$$
$$RMax(i) = max(RMax(i+1), h(i+1))$$

但这个题可以有一个巧妙的解法，只需要一次遍历就能得到结果。我们可以使用双指针的方法，从两边向中间遍历，设置两个指针 $left$ 和 $right$，并维护两个变量 $left\_max$ 和 $right\_max$，分别代表左边和右边的最大值。
因此，我们可以发现，$left\_max = LMax(left)$, $right\_max = RMax(right)$。

不失一般性，我们先考虑位置 $left$ ，$LMax(left)$能够通过 $left\_max$ 来维护，而 $RMax(left)$ 是未知的，但我们可以通过判断 $left\_max$ 和 $right\_max$ 的大小来间接的知道$RMax(left)$的范围。

如果 $left\_max < right\_max$，那么我们可以确定 $LMax(left) < right\_max \leq RMax(left)$，此时 $f(left) = min(LMax(left), RMax(left)) - h(left) = left\_max - h(left)$。

同理，当 $left\_max \geq right\_max$ 时，$f(right) = right\_max - h(right)$。

## 代码

```c++
int trap(vector<int>& h) {
    int l = 0, r = h.size() - 1, lmax = 0, rmax = 0, ans = 0;
    while (l < r) {
        lmax = max(lmax, h[l]), rmax = max(rmax, h[r]);
        ans += h[l] < h[r] ? lmax - h[l++] : rmax - h[r--];
    }
    return ans;
}
```