---
title: C++ 知识碎片
tags: C++
aside:
  toc: true
---


<!--more-->


- 检查函数是否修改通过引用或指针传递的参数，如果不修改，应该使用 `const` 修饰参数。
  - 如果成员函数不修改对象，应该使用 `const` 修饰函数。
- range-for 语句中，应该使用 `auto` 关键字，避免类型错误。如果不修改元素，应该使用 `const` 修饰。
- 使用标准库中的类型和函数，避免自己造轮子。
- 执行查找常见的模式，看是否有更好的替代方案, 使得代码更清晰地表达意图
  - 简单的for循环，可以使用 `std::for_each` 或 `range_for`。
  - f(T*, int) 接口 vs. f(span<T>) 接口
    - > span 是 C++20 中引入的一个新的标准容器，它用于表示连续的一段内存区间，类似于一个轻量级的只读数组容器。
- 不要将可以在编译时可以很好完成的工作推迟到运行时。
- 不能在编译时检查的内容应在运行时检查
- class 专属常量是指只能在类内部使用的常量，可以使用 `static const` 来定义。
  - static 成员变量只能在类外初始化（为了避免静态变量被多次初始化）
    - static const类型除了整型数可以在类内初始化(只是一个申明式，还要在类外提供定义)，其他的只能在类外初始化。
  - 如果是是一个`static const 整数类型`成员变量，我们可以使用它们而无需提供定义式，但要取地址时，必须提供定义式。
  - 在C++11中加入了类内初始化，常规的数据成员变量能在类内、构造函数里和初始化列表里进行初始化。const类型的成员变量只能在初始化列表里并且必须在这里进行初始化。static类型只能在类外进行初始化。static const类型除了整型数可以在类内初始化，其他的只能在类外初始化。
enum hack
: 是旧式枚举的经典用法，它是把枚举元素用做一个编译时整型常量来用，在C++ 模板元编程中特别常用。
- 如果一个函数返回一个值类型，也可以考虑将该值声明为const，这样可以避免用户的误操作。
- 如果一个成员函数有两个版本，一个是 const 修饰的，一个是非 const 修饰的，为了避免代码重复，可以将 非const 修饰的版本调用 const 修饰的版本。
```cpp
class A {
public:
    const int  f() const {
       // do something
    }
    int f() {
      return const_cast<int*>(static_cast<const A*>(this)->f());
    }
};
```
- 无论是定义于global、namespace作用域内的对象、在class内、在函数内、以及在file作用域内被声明为static的对象，它们都放在静态存储区域，其寿命为整个程序的运行期间。
- 多个文件中非局部static变量的依赖关系的解决方法
  - > 将非局部static变量放在一个专属函数内变为一个局部static变量，这样就可以保证这个变量只在这个函数内可见，只有第一次调用这个函数才会初始化这个变量。这是单例模式的一种实现方式。
- 不在构造函数和析构函数中调用虚函数
  - > 在构造函数调用虚函数，会导致继承类的构造函数中调用的是基类的虚函数，而不是派生类的虚函数。因为在构造函数中，派生类的成员（包括虚函数指针）还没有初始化。
- 使自己重载的operator=、 operator+ .... 返回一个reference to *this
  - > 使自己重载的operator=返回一个reference to *this，这样可以支持连续赋值，如 a=b=c=d。
- 在拷贝赋值运算符 `operator=` 中，应该检查是否是自我赋值。

一个简单的例子：
```cpp
class Bitmap {...};
class Widget {
  ...
private:
  Bitmap *pb;
};
```
下面是一个错误的实现：
```cpp
Widget& Widget::operator=(const Widget& rhs) {
  delete pb;
  pb = new Bitmap(*rhs.pb);
  return *this;
}
```
> 如果 `rhs` 和 `*this` 是同一个对象，那么 `delete pb` 会删除 `rhs.pb`，然后 `pb = new Bitmap(*rhs.pb)` 会复制一个已经被删除的对象，这是错误的。正确的实现如下：

```cpp
Widget& Widget::operator=(const Widget& rhs) {
  if (this == &rhs) return *this;
  delete pb;
  pb = new Bitmap(*rhs.pb);
  return *this;
}
```
但是，如果 `new Bitmap` 的抛出异常，那么 `pb` 就会被删除，但是没有被赋值，这样就会导致 `pb` 指向一个已经被删除的对象。正确的实现如下：
```cpp
Widget& Widget::operator=(const Widget& rhs) {
  Bitmap *pOrig = pb;
  pb = new Bitmap(*rhs.pb);
  delete pOrig;
  return *this;
}
```